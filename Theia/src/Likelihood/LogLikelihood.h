#pragma once
#include <vector>
#include <iostream>
#include <string>
#include <iomanip>
#define EIGEN_STACK_ALLOCATION_LIMIT 0 
#include "../libs/Eigen/Core"
#include "../libs/Eigen/Householder"
#include "../libs/Eigen/QR"
#include <algorithm>

#define EIGEN_MPL2_ONLY

#include "../Main/EfficiencyVector.h"
#include "../DataHandling/Star.h"
#include "../Main/GlobalVariables.h"
#include "DataStorage.h"
#include "ProbabilityFunctions.h"
using Eigen::VectorXd;
using namespace Eigen;
/*!
 This class holds the data and functions necessary to calculate log p(data | x), where x is the provided EfficiencyVector. The majority of the guts + internal workings of the class are hidden away in the LikelihoodData.
*/
class LogLikelihood
{
	public:
		
		//! The last-calculated value of the Calculate() function
		double Value; 
		
		//! The last-calculated gradient of the Calculate() function with respect to the associated `position`-- this is eventually summed into EfficiencyVector::TransformedGradient
		std::vector<double> Gradient;
		
		//! The number of stars within the last-called minibatch
		int StarsUsed;
		
		/*!
		 \brief Constructor function. 
		 \param data A vector of Star objects arranged according to the minibatching schedule. 
		*/
		LogLikelihood(const std::vector<std::vector<Star>> & data);
		
		/*!The key function: executes a single minibatch calculation of the loglikelihood. Loops over each star and calls PerStarContribution()
		 \param position The current EfficiencyVector
		 \param batchID The minibatch to be executed
		 \param effectiveBatches The current number of active minibatches
		 \param maxBatches The original number of active minibatches
		 \returns Assigns the value of L to #Value, and the associated gradient to #Gradient
		*/
		void Calculate(const EfficiencyVector & position, int batchID, int effectiveBatches, int maxBatches);
		
	protected:
		
		//! The storage for most of the Gnarly bits of this function, hides a lot of nasty stuff away in here
		LikelihoodData Data;

		//! Cleans the #Value and #Gradient to make way for a new loop 
		void Reset();
		
		/*! Calculates the likelihood contribution of an individual star, given the proposed efficiency vector. The results are accumulated into #Value and #Gradient. 
		 * \param batchId the current id of the minibatch loop
		 * \param starId the id of the star within the minibatch
		 * \param position the proposed effiency vector 
		 */
		void PerStarContribution(int batchId, int starID,const EfficiencyVector & position);
		
		/*! Given a star, calculate the temporal and spatial probabilities associated with it, following  \verbatim embed:rst:inline :ref:`our probability model <model>` \endverbatim. \param candidate A pointer to the star being evaluated \param position, the current proposed efficency vector*/
		void GeneratePs(const Star * candidate,const EfficiencyVector & position);
		
		/*! After GeneratePs() has produced probabilities, call either the PoissonBinomial function or the NormalApproximation \param candidate A pointer to the star being evaluated
		 */
		void GenerateContribution(const Star * candidate);
		
		/*!
		 * Translates the temporary gradients stored in #Data, via the chain rule, into results appropriate for summing into #Gradient
		 */
		void AssignGradients(const Star * candidate);
		
		//! Calculates the p(k = K | {p_i}) for the NormalApproximation to the PoissonBinomial. Here {p_i} is the set of probabilities generated by GeneratePs() and K is Star::nMeasure for the candidate \param candidate A pointer to the star being evaluated
		void NormalContribution(const Star * candidate);
		
		
		//! Calculates the p(k = K | {p_i}) for the PoissonBinomial, with a small truncation to the calculation. Here {p_i} is the set of probabilities generated by GeneratePs() and K is Star::nMeasure for the candidate \param candidate A pointer to the star being evaluated
		void PoissonContribution(const Star * candidate);
		
		//!Calculates the p(k = K | {p_i}) for the PoissonBinomial, **without** the truncation of PoissonContribution(). This is only called if one of the {p_i}s is close to zero or one, or the approximation otherwise results in a divergence \param candidate A pointer to the star being evaluated
		void ExactPoissonContribution(const Star * candidate);
		
		
};
